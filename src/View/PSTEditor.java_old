package View;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.LookAndFeel;
import javax.swing.UIManager;
import javax.swing.border.MatteBorder;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;

import exception.InvalidListToCreatePositiveScoreTable;
import extraction.PositiveScoreTable;
import model.AnnotationColumn;
import model.Corpus;
import net.miginfocom.swing.MigLayout;
import sun.swing.table.DefaultTableCellHeaderRenderer;

/**
 * Frame which enable to edit the positive score table.
 * The modifications can be saved only in viesa or in both viesa and a file.
 * @author zach
 *
 */
public class PSTEditor extends JDialog{
	
	private static final long serialVersionUID = 3009343889307416197L;
	boolean[][] cellModified;
	PSTTable psttable;
	PSTTableModel pstTableModel;
	JPanel jp_button;
	StandardView parent;
	JTableHeader header;

	private List<ArrayList<String>> rowdata;
	Color cellRemovedColor = new Color(237, 174, 174);
	Color rowModifiedColor = new Color(160, 160, 236);
	public static Color black = new Color(0, 0, 0);
	
	private PositiveScoreTable result;
	
	public PSTEditor(StandardView parent){

		super(parent, "Similarity scores", true);
		
		this.parent = parent;

		/* -1 because we don't display the empty annotation */
		cellModified = new boolean[Corpus.getCorpus().getNumberOfAnnotations() - 1][Corpus.getCorpus().getNumberOfAnnotations()];
		
		/* Set the size of the JDialog */
		Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
		int screen_height = (int)screenSize.getHeight();
		int screen_width = (int)screenSize.getWidth();
		
		int table_width = Math.min(screen_width, -15 + 75 * (Corpus.getCorpus().getNumberOfAnnotations()));
		int table_height = Math.min(screen_height,91 + 23*(Corpus.getCorpus().getNumberOfAnnotations() - 1));
		this.setSize(table_width, table_height);
		this.setLocationRelativeTo(null);
		this.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
		
		/* Main panel of the JDialog */
		JPanel jp = new JPanel();
		jp.setLayout(new MigLayout("fill"));
		
		psttable = new PSTTable(AnnotationColumn.pst);
		psttable.getTableHeader().setReorderingAllowed(false);
		psttable.setShowGrid(false);
		psttable.setIntercellSpacing(new Dimension(0,0));
		psttable.repaint();
		
		psttable.getJSP().setPreferredSize(new Dimension(table_width, table_height));
//		psttable.getJSP().setMinimumSize(new Dimension(table_width, Math.min(screen_height,table_height)));

	    FocusListener fl = new FocusListener() {
	        @Override public void focusGained(FocusEvent e) {
	          e.getComponent().repaint();
	        }
	        @Override public void focusLost(FocusEvent e) {
	          e.getComponent().repaint();
	        }
	      };
	      
	      psttable.addFocusListener(fl);
	      psttable.getJSP().addFocusListener(fl);
	      
		header = psttable.getTableHeader();
		header.setDefaultRenderer(new HeaderRenderer(psttable));

		JButton jb_ok = new JButton("OK");
		JButton jb_ok_plus_save = new JButton("OK + Save as");
		JButton jb_cancel = new JButton("Cancel");
		JHelpButton jhb_help = new JHelpButton(parent, "<html>This window is used to modify the similarity scores. <br><br>" +
				"The cells of the table can be edited by double-clicking on them.<br><br>" +
				"Buttons:<br>" +
				"- OK : only save the modifications in the current session;<br>" +
				"- OK and save as: save the modifications in the current session as well as in a file.</html>");


		jb_ok.addActionListener(new ActionListener(){
			public void actionPerformed(ActionEvent e){
				
				PSTEditor.this.confirm("Custom table");	
			}
		});
		
		jb_ok_plus_save.addActionListener(new ActionListener(){
			public void actionPerformed(ActionEvent e){
				
				JFileChooser chooser = new JFileChooser();
				chooser.setMultiSelectionEnabled(false);
				chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
				
				int returnVal = chooser.showOpenDialog(PSTEditor.this.parent);
				
				String tableName = "Custom table";
				
				if(returnVal == JFileChooser.APPROVE_OPTION){	
					try {
						PositiveScoreTable.saveInFile(chooser.getSelectedFile(), getCorrespondingALAL());
						tableName = chooser.getSelectedFile().getName();
					} catch (InvalidListToCreatePositiveScoreTable e1) {
						PSTEditor.this.parent.abstractException(e1);
					}
				}
				
				PSTEditor.this.confirm(tableName);	
			}
		});
		
		jb_cancel.addActionListener(new ActionListener(){
			public void actionPerformed(ActionEvent arg0) {
				setVisible(false);
			}			
		});
		
		jp_button = new JPanel(new MigLayout("", "[][][][]", ""));
		jp_button.add(jb_ok);
		jp_button.add(jb_ok_plus_save);
		jp_button.add(jb_cancel);
		jp_button.add(jhb_help);
		
		jp.add(psttable.getJSP(), "grow,wrap");
		jp.add(jp_button);
		
		this.setContentPane(jp);
		

	}

	public class PSTTable extends JTable{

		private static final long serialVersionUID = 1L;
		private JScrollPane jsp_parent;
		public PSTTable(PositiveScoreTable pst){
			
			super();
			
			jsp_parent = new JScrollPane(this, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
			jsp_parent.getVerticalScrollBar().setUnitIncrement(10);
			jsp_parent.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
//			jsp_parent.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
			this.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
			
			pstTableModel = new PSTTableModel(pst);
			this.setModel(pstTableModel);	
			
			PSTTableRenderer rend = new PSTTableRenderer();

			int gap = 11;
			int width = this.getJSP().getWidth() - (gap * (this.getColumnCount() + 1));
			int size = Math.max(width/this.getColumnCount(), 4*gap);	
			
			this.getJSP().getViewport().setBackground(new Color(215, 215, 215));
			
			for(int i = 0 ; i < this.getColumnCount() ; i++){

				TableColumn column = this.getColumnModel().getColumn(i);
				column.setMinWidth(size);
				column.setCellRenderer(rend);
				
			}	
			
			// Row headers 
			DefaultTableModel headerData = new DefaultTableModel(0, 1);

			RowHeaderRenderer rhr = new RowHeaderRenderer(this.getTableHeader().getDefaultRenderer());
			
        	for (int i = 0; i < this.getColumnCount(); i++)
	            headerData.addRow(new Object[] {Corpus.getCorpus().getAnnotation(i+1) });
	            

        	
			JTable rowHeader = new JTable(headerData);

            rowHeader.getColumnModel().getColumn(0).setCellRenderer(rhr);
			
			LookAndFeel.installColorsAndFont(rowHeader, "TableHeader.background", "TableHeader.foreground", "TableHeader.font");
			rowHeader.setIntercellSpacing(new Dimension(0, 0));
			
			Color color = UIManager.getColor("Table.gridColor");
			MatteBorder border = new MatteBorder(1, 1, 0, 0, color);
			rowHeader.setBorder(border);
			
			/* Get the maximal width of a row header */
        	width = 0;
        	 for (int row = 0; row < rowHeader.getRowCount(); row++) {
        	     TableCellRenderer renderer = rowHeader.getCellRenderer(row, 0);
        	     Component comp = rowHeader.prepareRenderer(renderer, row, 0);
        	     width = Math.max (comp.getPreferredSize().width, width);
        	 }
			
			Dimension d = rowHeader.getPreferredScrollableViewportSize();
			rowHeader.getMaximumSize();
			
			d.width = width;
			rowHeader.setPreferredScrollableViewportSize(d);
		        
			jsp_parent.add(rowHeader);
			jsp_parent.setRowHeaderView(rowHeader);
			 
			
		}
		
		public JScrollPane getJSP(){
			return jsp_parent;
		}
		
	}

	
	public PositiveScoreTable showThis(){
		this.setVisible(true);
		

		
		return result;		
	}
	
	public List<ArrayList<String>> getCorrespondingALAL(){
		
		List<ArrayList<String>> data = new ArrayList<>();
		
		for(short i = 0 ; i < rowdata.size() ; ++i)
			for(short j = 0 ; j <= i ; ++j){
				
				String s = rowdata.get(i).get(j);
				
				try{

					/* If the value associated to annotations <i> and <j> is a double greater than 0 */
					if(Double.parseDouble(s) >= 0.0){
				
						ArrayList<String> newValues = new ArrayList<>();
						newValues.add(Corpus.getCorpus().getAnnotation(i+1));
						newValues.add(Corpus.getCorpus().getAnnotation(j+1));
//						newValues.add(rowdata.get(i).get(0));
//						newValues.add(rowdata.get(j).get(0));

						
						newValues.add(s);

						data.add(newValues);
					}
										
				}catch(NumberFormatException e){}
				
			}
		
		return data;
		
	}


	private void confirm(String path) {

		try {
			
			/* Change the focus to save the modification of the last edited cell (if it has not been validated by pressing enter or changing the focus) */
			psttable.requestFocus();
			psttable.editCellAt(0,0);
						
			result = new PositiveScoreTable(getCorrespondingALAL());
			result.setPath(path);
			
		} catch (InvalidListToCreatePositiveScoreTable e) {
			parent.abstractException(e);
		}
		
		setVisible(false);
		
	}
	
	@SuppressWarnings("serial")
	private class PSTTableModel extends AbstractTableModel{
		private String[] columnNames;
		
		public PSTTableModel(PositiveScoreTable pst){
			
			rowdata = new ArrayList<ArrayList<String>>();
			ArrayList<String> currentLine;
			
			/* For each line in the table */
			for(short i = 1 ; i < pst.size() ; ++i){
				
				currentLine = new ArrayList<String>();
				
				/* For each non empty column in this line */
				for(short j = 1; j <= i ; ++j){
					
					
					/* If the value associated to annotations <i> and <j> is greater than 0 */
					double v = pst.get(i, j);
					
					if(v > 0.0)
						currentLine.add(((Double)v).toString());
					else
						currentLine.add("-");
				}
				for(int j = i+1 ; j < Corpus.getCorpus().getNumberOfAnnotations() ; ++j)

					currentLine.add("");
					rowdata.add(currentLine);
			}
			
			/* For each annotation which does not appear in the table */
			for(int i = pst.size() ; i < Corpus.getCorpus().getNumberOfAnnotations() ; ++i){

				currentLine = new ArrayList<String>();
//				currentLine.add(Corpus.getCorpus().getAnnotation(i));
				
				/* For each column in the table */
				for(int j = 1; j <= i ; ++j)
					currentLine.add("-");
				for(int j = i+1 ; j < Corpus.getCorpus().getNumberOfAnnotations() ; ++j)
					currentLine.add("");
				rowdata.add(currentLine);
			}
						
			columnNames = new String[Corpus.getCorpus().getNumberOfAnnotations()];
			
			for(int i = 1 ; i < pst.size() ; ++i)
				columnNames[i-1] = Corpus.getCorpus().getAnnotation(i);
			
		}

		@Override
		public int getColumnCount() {
			if(rowdata != null && rowdata.size() > 0)
				return rowdata.get(0).size();
			else
				return 0;
		}

		@Override
		public int getRowCount() {
			return rowdata.size();
		}

		@Override
		public Object getValueAt(int arg0, int arg1) {
			return rowdata.get(arg0).get(arg1);
		}
		
		public String getColumnName(int c){
			return columnNames[c];
		}
		
		@Override
		public void setValueAt(Object value, int row, int col) {
			
			if(!value.equals(rowdata.get(row).get(col))){
				cellModified[row][col] = true;
	
			    rowdata.get(row).set(col, value.toString());
			     
			    fireTableCellUpdated(row, col);
			}
		    
		  }

    	public boolean isCellEditable(int row, int col){
    		if(col > row)
    			return false;
    		else
    			return true; 
    	}
		
	}
	
	@SuppressWarnings("serial")
	private class PSTTableRenderer extends DefaultTableCellRenderer{
		
		public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column){ 

			
			super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column); 

			if(column > row)
				this.setBackground(new Color(215, 215, 215));
			else if(cellModified[row][column])
				this.setBackground(rowModifiedColor);
    		else if( row % 2 == 0 )  
    			this.setBackground(new Color(232, 231, 248));
    		else
    			this.setBackground(new Color(255,255,255));	
			
			this.setForeground(black);
	
			String valueDisplayed;
			
			/* Bug from java, getTableCellRendererComponent is sometime called with value == null
			 * http://stackoverflow.com/questions/3054775/jtable-strange-behavior-from-getaccessiblechild-method-resulting-in-null-point
			 * https://josm.openstreetmap.de/ticket/6301
			 */
			try{
				valueDisplayed = value.toString();
				if(column > 0)
					this.setHorizontalAlignment(JLabel.CENTER); 
				else
					this.setHorizontalAlignment(JLabel.LEFT); 
				
				setText(valueDisplayed);
			}catch(NullPointerException e){}

	    	return this; 
	    	
		}
		
	}
	
	/**
	 * Class used to center the column headers 
	 * @author zach
	 *
	 */
	private static class HeaderRenderer implements TableCellRenderer {

	    DefaultTableCellRenderer renderer;

	    public HeaderRenderer(JTable table) {
	        renderer = (DefaultTableCellRenderer)
	            table.getTableHeader().getDefaultRenderer();
	        renderer.setHorizontalAlignment(JLabel.CENTER);
	    }

	    @Override
	    public Component getTableCellRendererComponent(
	        JTable table, Object value, boolean isSelected,
	        boolean hasFocus, int row, int col) {
//	    	
//	    	if(col > AnnotationColumn.pst.size()){
//	    		
//	    	}
	        return renderer.getTableCellRendererComponent(
	            table, Corpus.getCorpus().getAnnotation(col+1), isSelected, hasFocus, row, col);
	    }
	}
	
	private class RowHeaderRenderer extends DefaultTableCellHeaderRenderer implements javax.swing.plaf.UIResource{
	    
	    private final TableCellRenderer defRenderer;

	    RowHeaderRenderer (TableCellRenderer defRenderer) {
	      this.defRenderer = defRenderer;
	    }

	    @Override
	    public Component getTableCellRendererComponent(
	            JTable table, Object value, boolean isSelected,
	            boolean hasFocus, int row, int column)
	    {
	    	Component c = defRenderer.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
	    	
	        return c;
	    }
	    
	    @Override
	    public void updateUI() {
	      TableCellRenderer locDefRenderer = defRenderer;
	      if (locDefRenderer instanceof JComponent) {
	        ((JComponent) locDefRenderer).updateUI();
	      } else {
	        super.updateUI();
	      }
	    }
	    
	}

}
